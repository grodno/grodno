// Generated by CoffeeScript 1.8.0
(function() {
  var SampleApp, express, fs;

  Object.http = (function() {
    var MIME, REASON_CODES, http, request, _hasBody, _mime, _perform;
    http = require("http");
    request = require("request");
    _perform = function(ev) {
      Object.debug("Remote HTTP request", "" + ev.uri);
      request.get("" + ev.uri, ev.options, function(err, response, body) {
        if (!err && response.statusCode === 200) {
          console.log(body);
        }
        ev.callback(err, body);
      });
    };
    Object.entity.create({
      id: "EventHandler:http",
      handleEventImpl: _perform
    });
    Object.entity.create({
      id: "EventHandler:https",
      handleEventImpl: _perform
    });
    http.withFileContent = function(fileName, cb, encoding) {
      var name;
      name = path.join(global.__root, fileName);
      path.exists(name, function(x) {
        if (x) {
          fs.readFile(name, encoding, cb);
        } else {
          cb({
            reason: "not-found",
            message: "Not found: " + fileName
          });
        }
      });
    };
    MIME = http.MIME = {
      URL_ENCODED: "application/x-www-form-urlencoded",
      JSON: "application/json",
      JS: "text/javascript",
      HTML: "text/html",
      CSS: "text/css",
      IMAGE: "image/*",
      JPG: "image/jpg",
      PNG: "image/png",
      GIF: "image/gif",
      TXT: "text/plain",
      APPCACHE: "text/cache-manifest"
    };

    /*
    Return `true` if the request has a body, otherwise return `false`.
    
    @param  {IncomingMessage} req
    @return {Boolean}
    @api private
     */
    _hasBody = function(req) {
      return "transfer-encoding" in req.headers || "content-length" in req.headers;
    };

    /*
    Extract the mime type from the given request's
    _Content-Type_ header.
    
    @param  {IncomingMessage} req
    @return {String}
    @api private
     */
    _mime = function(req) {
      var str;
      str = req.headers["content-type"] || "";
      return str.split(";")[0];
    };
    REASON_CODES = http.REASON_CODES = {
      ok: 200,
      bad: 400,
      conflict: 409,
      forbidden: 403,
      "not-found": 404,
      "method-not-allowed": 405,
      "internal-server-error": 500
    };
    http.fetchPayload = function(ev, req, next) {
      if (["get", "delete"].indexOf(req.method) === -1) {
        req.addListener("data", function(chunk) {
          ev.body += chunk;
        });
        req.addListener("end", function() {
          Object.http.parsePayload(ev, function() {
            next(err, ev);
          });
        });
      } else {
        this(err, ev);
      }
    };
    http.parsePayload = function(ev, cb) {
      var ch0, e, mime, parser, xml2js;
      mime = ev.headers["content-type"];
      ch0 = ev.body[0];
      if (mime === MIME.URL_ENCODED) {
        ev.payload = Object.parseUri("?" + ev.body).params;
        cb();
      } else if (mime.indexOf("xml") > -1 || ch0 === "<") {
        xml2js = require("xml2js");
        parser = new xml2js.Parser();
        parser.parseString(ev.body, cb);
      } else if (ch0 === "{" || ch0 === "[") {
        try {
          ev.payload = JSON.parse(ev.body);
        } catch (_error) {
          e = _error;
          this.error("bad", "Bad JSON payload format: " + ":" + e);
        }
        cb();
      } else {
        cb();
      }
    };
    http.xmlPayloadParser = function(options) {
      options = options || {};
      return function(req, res, next) {
        var buf;
        if (req._body) {
          return next();
        }
        req.body = req.body || {};
        if (!_hasBody(req)) {
          return next();
        }
        if (["application/xml", "application/atom+xml", "application/rss+xml"].indexOf(_mime(req)) === -1) {
          return next();
        }
        req._body = true;
        buf = "";
        req.setEncoding("utf8");
        req.on("data", function(chunk) {
          buf += chunk;
        });
        req.on("end", function() {
          var first, parser, xml2js;
          first = buf.trim()[0];
          if (0 === buf.length) {
            return next(400, "invalid json, empty body");
          }
          xml2js = require("xml2js");
          parser = new xml2js.Parser();
          parser.parseString(buf, function(err, result) {
            if (err) {
              err.body = buf;
              err.status = 400;
              next(err);
            } else {
              req.body = result;
              next();
            }
          });
        });
      };
    };
    http.negotiateMime = function(url) {
      var ext, p;
      p = url.lastIndexOf(".");
      ext = url.substring(p + 1).toUpperCase();
      return MIME[ext] || MIME.HTML;
    };
    http.send = function(res, result, mime, reason) {
      var code;
      code = (reason ? REASON_CODES[reason] || 500 : 200);
      res.writeHead(code, http.STATUS_CODES[code], {
        "Content-Type": mime || MIME.HTML
      });
      res.end(result);
    };
    http.sendJson = function(res, obj, reason) {
      this.send(res, JSON.stringify(obj), MIME.JSON, reason);
    };
    http.sendError = function(res, err, message) {
      err = http.narrowError(err, message);
      http.sendJson(res, err, err.reason);
      return err;
    };
    http.narrowError = function(err, message) {
      err = Object.error(err || {}, message);
      if (!err.reason || !REASON_CODES[err.reason]) {
        err.reason = "internal-server-error";
      }
      if (!err.message) {
        err.message = http.STATUS_CODES[REASON_CODES[err.reason]];
      }
      return err;
    };
    return http;
  })();

  Object.fs = (function() {
    var fs, path;
    fs = require("fs");
    path = fs.path = require("path");
    fs.withFileContent = function(fileName, cb, encoding) {
      var name;
      name = path.join(global.__root, fileName);
      path.exists(name, function(x) {
        if (x) {
          fs.readFile(name, encoding, cb);
        } else {
          cb({
            reason: "not-found",
            message: "Not found: " + fileName
          });
        }
      });
    };
    Object.entity.create({
      id: "EventHandler:file",
      handleEventImpl: function(ev) {
        fs.withFileContent(ev.uri.steps.join("/"), (function(err, content) {
          if (content) {
            Object.http.send(ev.res, content, Object.http.negotiateMime("" + ev.uri));
          } else {
            Object.http.sendError(ev.res, "not-found", "Url not found: " + ev.uri);
          }
        }), ev.encoding);
      }
    });
    return fs;
  })();


  /*
   Define the sample application.
   */

  express = require("express");

  fs = require("fs");

  SampleApp = function() {
    var self;
    self = this;

    /*
    Set up server IP address and port # using env variables/defaults.
     */
    self.setupVariables = function() {
      self.ipaddress = process.env.OPENSHIFT_NODEJS_IP || process.env.IP;
      self.port = process.env.OPENSHIFT_NODEJS_PORT || process.env.PORT || 8000;
      if (typeof self.ipaddress === "undefined") {
        console.warn("No predefined IP vars, using 127.0.0.1");
        self.ipaddress = "127.0.0.1";
      }
    };

    /*
    Populate the cache.
     */
    self.populateCache = function() {
      if (typeof self.zcache === "undefined") {
        self.zcache = {
          "index.html": ""
        };
      }
      self.zcache["index.html"] = fs.readFileSync("./static/index.html");
    };

    /*
    Retrieve entry (content) from cache.
    @param {string} key  Key identifying content to retrieve from cache.
     */
    self.cache_get = function(key) {
      return self.zcache[key];
    };

    /*
    terminator === the termination handler
    Terminate server on receipt of the specified signal.
    @param {string} sig  Signal to terminate on.
     */
    self.terminator = function(sig) {
      if (typeof sig === "string") {
        console.log("%s: Received %s - terminating sample app ...", Date(Date.now()), sig);
        process.exit(1);
      }
      console.log("%s: Node server stopped.", Date(Date.now()));
    };

    /*
    Setup termination handlers (for exit and a list of signals).
     */
    self.setupTerminationHandlers = function() {
      process.on("exit", function() {
        return self.terminator();
      });
      ["SIGHUP", "SIGINT", "SIGQUIT", "SIGILL", "SIGTRAP", "SIGABRT", "SIGBUS", "SIGFPE", "SIGUSR1", "SIGSEGV", "SIGUSR2", "SIGTERM"].forEach(function(element, index, array) {
        process.on(element, function() {
          self.terminator(element);
        });
      });
    };

    /*
    Create the routing table entries + handlers for the application.
     */
    self.createRoutes = function() {
      self.routes = {};
      self.routes["/"] = function(req, res) {
        res.setHeader("Content-Type", "text/html");
        res.send(fs.readFileSync("./static/index.html"));
      };
    };

    /*
    Initialize the server (express) and create the routes and register
    the handlers.
     */
    self.initializeServer = function() {
      var r;
      self.createRoutes();
      self.app = express();
      self.app.use(express["static"]('./static'));
      for (r in self.routes) {
        self.app.get(r, self.routes[r]);
      }
    };

    /*
    Initializes the sample application.
     */
    self.initialize = function() {
      self.setupVariables();
      self.populateCache();
      self.setupTerminationHandlers();
      self.initializeServer();
      return self;
    };

    /*
    Start the server (starts up the sample application).
     */
    self.start = function() {
      self.app.listen(self.port, self.ipaddress, function() {
        console.log("%s: Node server started on %s:%d ...", Date(Date.now()), self.ipaddress, self.port);
      });
      return self;
    };
  };

  module.exports = function() {
    return new SampleApp();
  };

}).call(this);
