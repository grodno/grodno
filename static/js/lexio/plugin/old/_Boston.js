// Generated by CoffeeScript 1.7.1
(function() {
  (function() {
    var Token, ZToken, compileTemplate, _tokenize;
    Token = function(v, m, prev) {
      this.id = m.origin || v;
      this.input = v;
      this.size = 1;
      this.kind = m.kind;
      this.tags = [];
      if (prev) {
        this.prev = prev;
        prev.next = this;
      }
    };
    ZToken = function(t, prev) {
      this.id = t.id;
      this.input = t.input || +t.id;
      this.size = t.id.length;
      this.kind = "z";
      this.type = t.type;
      this.tags = (t.tags || []).concat("type-" + this.type);
      if (prev) {
        this.prev = prev;
        prev.next = this;
      }
    };
    Token.prototype = ZToken.prototype = {
      remove: function() {
        this.kind = null;
        this.prev && (this.prev.next = this.next);
        this.next && (this.next.prev = this.prev);
      },
      setNext: function(n) {
        this.next = n;
        if (n) {
          n.prev = this;
        }
      },
      setPrev: function(p) {
        this.prev = p;
        if (p) {
          p.next = this;
        }
      }
    };
    _tokenize = (function(v, p, ev) {
      var id, m, prev;
      prev = ev.lastToken;
      if (!v) {
        v = {
          type: "x",
          id: "error",
          input: "[error]"
        };
      }
      if (v.type) {
        this.push(ev.lastToken = new ZToken(v, prev));
      } else {
        m = String.CHARS[v] || (String.CHARS[v] = {
          kind: "x",
          lat: "",
          id: v,
          type: v,
          origin: v
        });
        if (prev && (prev.kind === m.kind)) {
          id = m.origin || v;
          prev.input += v;
          prev.id += id;
          prev.size++;
        } else {
          this.push(ev.lastToken = new Token(v, m, prev));
        }
      }
      if (!prev) {
        ev.firstToken = ev.lastToken;
      }
    }).iterator();
    compileTemplate = function(s) {
      var path, posB, posE, r;
      posB = void 0;
      posE = -2;
      path = void 0;
      r = [];
      while (((posB = s.indexOf("{{")) > -1) && ((posE = s.indexOf("}}", posB)) > -1)) {
        path = s.substring(posB + 1, posE + 1);
        r.push.apply(r, s.substring(0, posB).split(""));
        r.push(Object.parse(path));
        s = s.substring(posE + 2);
      }
      s && r.push.apply(r, s.split(""));
      return r;
    };
    Object.entity.define({
      id: "lexio/plugin/tokenize extends lexio.Plugin",
      performImpl: function(err, ev) {
        var arr;
        arr = (ev.normalizedInput ? compileTemplate(ev.normalizedInput) : ev.input.split(""));
        _tokenize(arr, [], ev);
      }
    });
  })();

  (function() {
    var _iterator, _lat, _translite;
    _lat = function(ww) {
      var i, l, r;
      i = 0;
      r = "";
      l = ww.length;
      while (i < l) {
        r += String.CHARS[ww[i]].lat;
        i++;
      }
      return r;
    };
    _translite = function(c) {
      if (c.root && String.ROOTS[_lat(c.root)]) {
        c.score += 100;
        c.word.best = c;
      }
    };
    _iterator = (function(w, i) {
      if (!w.trasliterated && w.lang === "r" && w.best.score < 59) {
        w.trasliterated = 1;
        w.eachCase(_translite);
      }
    }).iterator();
    Object.entity.define("lexio/plugin/translit extends lexio/Plugin", {
      methods: function(_super) {
        return {
          performImpl: function(err, ev) {
            _iterator(String.WORDS, ev);
          }
        };
      }
    });
  })();

}).call(this);
