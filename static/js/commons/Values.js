// Generated by CoffeeScript 1.8.0
(function() {
  Object.entity.defineProperty({
    id: "ValueRange",
    methods: function() {
      return {
        init: Function.NONE,
        setter: function(v) {
          var v0, v1;
          v0 = this.valueRangePartAdapter(v[0]);
          v1 = this.valueRangePartAdapter(v[1]);
          this._valueRangeLocked = (this._valueRangeLocked || 0) + 1;
          this.prop("valueMin", v0);
          this.prop("valueMax", v1);
          this.prop("value", this.valueFromParts(v0, v1));
          this._valueRangeLocked--;
          this[propId] = [v0, v1];
          return v;
        },
        comparator: function(a, b) {
          return (!a && !b) || (a && b && a.length > 1 && (a.length === b.length) && (a[0] === b[0]) && (a[1] === b[1]));
        }
      };
    },
    mixin: function(_super) {
      return {
        valueChanged: function(ev, v) {
          if (!this._valueRangeLocked) {
            this._valueRangeLocked = (this._valueRangeLocked || 0) + 1;
            this.prop("valueRange", (v && v.split && (v = v.split("-")) && (v.length > 1) ? v : [null, null]));
            _super.valueChanged.call(this, ev, v);
            this._valueRangeLocked--;
          }
        },
        valueMinChanged: function(ev, v) {
          if (!this._valueRangeLocked) {
            this.prop("value", this.valueFromParts(v, this.valueMax));
          }
        },
        valueMaxChanged: function(ev, v) {
          if (!this._valueRangeLocked) {
            this.prop("value", this.valueFromParts(this.valueMin, v));
          }
        },
        valueRangePartAdapter: Function.NONE,
        valueFromParts: function(min, max) {
          return "" + (min || "") + "-" + (max || "");
        }
      };
    }
  });

  Object.entity.defineProperty({
    id: "BatchedProperties",
    mixin: function(_super) {
      return {
        init: function() {
          this._changeEvent = {
            entity: this,
            counter: 0,
            delta: {}
          };
          return _super.init.call(this);
        },
        batch: function(fn) {
          this._touch.counter++;
          fn && fn.apply(this, Array.prototype.slice.call(arguments_, 1));
          if (!--this._touch.counter) {
            return this.changed();
          }
        },
        changed: function() {
          this.notifyPropertyChanged("changed", this._changeEvent);
          return this._changeEvent.delta = {};
        },
        prop: function(key, val, asyncUrl, force) {
          var che;
          if (!this._done) {
            if (val && (val.value !== _undef || val.asyncUrl)) {
              if (val.asyncUrl) {
                asyncUrl = val.asyncUrl;
                delete val.asyncUrl;
              }
            } else {
              val = {
                value: val
              };
            }
            che = this._changeEvent;
            che.delta[key] = val.value;
            che.counter++;
            this._prop(key).setValue(this, val, asyncUrl, force);
            if (!--che.counter) {
              this.changed();
            }
          }
        }
      };
    }
  });

  Object.entity.defineProperty({
    id: "Bundle",
    mixin: function(_super) {
      var __actualDelta, __allKeys;
      __allKeys = function(obj) {
        var key, r;
        r = {};
        for (key in obj) {
          r[key] = null;
        }
        return r;
      };
      __actualDelta = function(obj, oldV) {
        var n, r;
        r = [];
        for (n in obj) {
          if (obj.hasOwnProperty(n) && (oldV[n] !== obj[n])) {
            r.push({
              id: n,
              value: obj[n]
            });
          }
        }
        return r;
      };
      return {
        setValue: function(d) {
          this.prop("value", d || __allKeys(this.value));
        },
        _get: function(key) {
          if (key === "value") {
            return this.value;
          } else {
            if (this.value) {
              return this.value[key];
            } else {
              return null;
            }
          }
        },
        prop: function(key, v) {
          var delta, _undef;
          _undef = void 0;
          if (!this._done) {
            if (!(v && (v.value !== _undef))) {
              v = {
                value: v
              };
            }
            if (!this.write_counter) {
              this.write_counter = 1;
              delta = void 0;
              if (key !== "value") {
                delta = {};
                delta[key] = v.value;
              } else {
                delta = v.value;
              }
              this.update(delta);
              this.write_counter--;
            } else {
              this.delayedDelta = this.delayedDelta || {};
              this.delayedDelta[key] = v.value;
            }
          }
        },
        update: function(dd) {
          var T, deltaArr, ev1, hook, oldV, v;
          T = this;
          v = Object.clone(dd);
          oldV = Object.clone(T.value || {});
          deltaArr = __actualDelta(v, oldV);
          if (deltaArr.length) {
            if (this.__update(v, false, oldV)) {
              ev1 = {
                entity: T,
                oldValue: oldV,
                value: T.value
              };
              hook = T.valueChanged;
              hook && hook.call(T, ev1, ev1.value);
              T.notifyPropertyChanged("value", ev1);
            }
          }
        },
        __update: function(delta, hasChanges, oldV) {
          var T, deltaArr, e, ev0, hook, i, id;
          this.value = this.value || {};
          T = this;
          deltaArr = __actualDelta(delta, oldV);
          i = 0;
          while (i < deltaArr.length) {
            e = deltaArr[i];
            id = e.id;
            ev0 = {
              entity: T,
              oldValue: oldV[id],
              value: e.value
            };
            T.value[id] = e.value;
            hook = T[id + "Changed"];
            hook && hook.call(T, ev0, ev0.value);
            T.notifyPropertyChanged(id, ev0);
            hasChanges = true;
            i++;
          }
          if (this.delayedDelta) {
            delta = T.delayedDelta;
            T.delayedDelta = null;
            return T.__update(delta, hasChanges, oldV);
          }
          return hasChanges;
        }
      };
    }
  });

}).call(this);
