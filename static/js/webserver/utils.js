// Generated by CoffeeScript 1.8.0
(function() {
  Object.entity.create({
    id: "request:EventHandler",
    handleEvent: function(ev) {
      Object.log("Remote HTTP request", "" + ev.uri);
      return request.get("" + ev.uri, ev.options, function(err, response, body) {
        if (!err && response.statusCode === 200) {
          console.log(body);
        }
        return ev.callback(err, body);
      });
    }
  });

  Object.http = (function() {
    var MIME, REASON_CODES, http, request, _hasBody, _mime;
    http = require("http");
    request = require("request");
    MIME = http.MIME = {
      URL_ENCODED: "application/x-www-form-urlencoded",
      JSON: "application/json",
      JS: "text/javascript",
      HTML: "text/html",
      CSS: "text/css",
      IMAGE: "image/*",
      JPG: "image/jpg",
      PNG: "image/png",
      GIF: "image/gif",
      TXT: "text/plain",
      APPCACHE: "text/cache-manifest"
    };
    REASON_CODES = http.REASON_CODES = {
      ok: 200,
      bad: 400,
      conflict: 409,
      forbidden: 403,
      "not-found": 404,
      "method-not-allowed": 405,
      "internal-server-error": 500
    };

    /*
    Return `true` if the request has a body, otherwise return `false`.
    
    @param  {IncomingMessage} req
    @return {Boolean}
    @api private
     */
    _hasBody = function(req) {
      return "transfer-encoding" in req.headers || "content-length" in req.headers;
    };

    /*
    Extract the mime type from the given request's
    _Content-Type_ header.
    
    @param  {IncomingMessage} req
    @return {String}
    @api private
     */
    _mime = function(req) {
      return (req.headers["content-type"] || "").split(";")[0];
    };
    http.fetchPayload = function(ev, req, next) {
      if (["get", "delete"].indexOf(req.method) === -1) {
        req.addListener("data", function(chunk) {
          ev.body += chunk;
        });
        req.addListener("end", function() {
          Object.http.parsePayload(ev, function() {
            next(err, ev);
          });
        });
      } else {
        this(err, ev);
      }
    };
    http.negotiateMime = function(url) {
      var ext, p;
      p = url.lastIndexOf(".");
      ext = url.substring(p + 1).toUpperCase();
      return MIME[ext] || MIME.HTML;
    };
    http.send = function(res, result, mime, reason) {
      var code;
      code = (reason ? REASON_CODES[reason] || 500 : 200);
      res.writeHead(code, http.STATUS_CODES[code], {
        "Content-Type": mime || MIME.HTML
      });
      res.end(result);
    };
    http.sendJson = function(res, obj, reason) {
      this.send(res, JSON.stringify(obj), MIME.JSON, reason);
    };
    http.sendError = function(res, err, message) {
      err = http.narrowError(err, message);
      http.sendJson(res, err, err.reason);
      return err;
    };
    http.narrowError = function(err, message) {
      err = Object.error(err || {}, message);
      if (!err.reason || !REASON_CODES[err.reason]) {
        err.reason = "internal-server-error";
      }
      if (!err.message) {
        err.message = http.STATUS_CODES[REASON_CODES[err.reason]];
      }
      return err;
    };
    return http;
  })();

}).call(this);
